// Invoke 'strict' JavaScript mode
'use strict';
var crypto = require('crypto');

module.exports = {
    _hash: function (s, t, p) {
        if (p && p.length > 0)
            return crypto.createHmac(t, p).update(s, 'utf8').digest('hex');
        else
            return crypto.createHash(t).update(s, 'utf8').digest('hex');
    },

    genId: function () {
        //var args = Array.prototype.slice.call(arguments);
        var args = Array.from(arguments);
        var id = args.join('').toLowerCase();
        return this.md5(id);
    },

    random: function (b) {
        return crypto.randomBytes(b ? b : 8).toString('hex');
    },
    md5: function (s, secret) {
        return this._hash(s, 'md5', secret);
    },
    sha1: function (s, secret) {
        return this._hash(s, 'sha1', secret);
    },
    sha256: function (s, secret) {
        return this._hash(s, 'sha256', secret);
    },
    sha512: function (s, secret) {
        return this._hash(s, 'sha512', secret);
    },
    pwd: function (s) {
        return this.sha256(this.sha512(s));
    },

   

    encrypt: function (s, secret) {        
        let iv = crypto.randomBytes(16);
        const key = crypto.scryptSync(secret, 'salt', 32);
        let cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
        // let cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(secret), iv);
        let encrypted = cipher.update(s);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        return iv.toString('hex') + ':' + encrypted.toString('hex');
    },
    decrypt: function (s, secret) {

        let a = s.split(':');
        let iv = Buffer.from(a[0], 'hex');       
        const key = crypto.scryptSync(secret, 'salt', 32);
        let decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
        let decrypted = decipher.update(Buffer.from(a[1], 'hex'));
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();

    }   

}